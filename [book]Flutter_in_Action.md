> Flutter in Action [에릭 윈드밀 지음, 우정은 옮김] <한빛미디어>



![](md-images/Flutter_in_Action.jpg)



# 1장 플러터

> 개발자로 반드시 알아야 할 플러터의 네 가지 주요 개념
>
> > 플러터는 리액티브다
> >
> > 모든 것은 위젯이다
> >
> > State 객체는 오래 살아남으며 종종 재사용된다
> >
> > 위젯의 제약은 부모가 서술한다



## 1.6 다른 모바일 개발 옵션

> 플러터와 다른 개발환경 비교



### 1.6.1 네이티브 개발

- 장점
  - 앱을 가장 완벽하게 제어하고, 디버깅 도구, 성능을 최대로 활용할 수 있음
- 단점
  - 플랫폼별로 앱을 두 번 구현해야 함



### 1.6.2 자바스크립트 기반 크로스 플랫폼

> 웹뷰, 리액트 네이티브 같은 자바스크립트 기반의 크로스 플랫폼

- 단점
  - 네이티브 개발 경험을 쌓을 수 없음
  - 자바스크립트 다리 - 병목현상 발생, 디버깅이 어려움, 속도가 느림
- 장점
  - 모든 프런트엔드 웹 개발자가 모바일 앱 개발에 참여하고 도울 수 있다



- 비교 - 플러터

  > 두 가지 요소 덕분에 앱이 네이티브로 구동됨

  - ARM 코드로 컴파일
    - ARM : 최신 모바일 디바이스, 웨어러블, 사물인터넷 기기 등에 사용하는 프로세서
  - 자체 렌더링 엔진 탑재



#### 렌더링 엔진

> Rendering engine - 화면상에 텍스트와 이미지를 그려주는 소프트웨어
>
> A **rendering engine** is software that draws text and images on the screen.
> The engine draws structured text from a document (often [HTML](https://developer.mozilla.org/en-US/docs/Glossary/HTML)), and formats it properly based on the given style declarations (often given in [CSS](https://developer.mozilla.org/en-US/docs/Glossary/CSS)). Examples of layout engines: [Blink](https://developer.mozilla.org/en-US/docs/Glossary/Blink), [Gecko](https://developer.mozilla.org/en-US/docs/Glossary/Gecko), EdgeHTML, [WebKit](https://developer.mozilla.org/en-US/docs/Glossary/WebKit).



## 1.7 플러터의 장점



### 1.7.1 자바스크립트 다리가 없음

- 플러터는 실제 네이티브 코드로 컴파일
- 크롬이 사용하는 렌더링 엔진 (스키아 [Skia])를 사용하여 실행 시 다트를 변환하지 않는다
- 따라서 사용자의 디바이스에서 플러터 앱을 실행해도 성능이나 생산성이 저하되지 않는다



### 1.7.2 컴파일 시간

- 플러터에서 전체 컴파일은 보통 30초가 걸리며, 핫 리로드 덕분에 점진적 컴파일은 1초 내외이다



### 1.7.3 한 번 구현하고, 한 번 테스트하고 모든 곳에 배포

- 다트 유닛 테스트는 아주 쉬우며, 플러터는 테스팅 위젯 라이브러리를 제공한다



### 1.7.4 코드 공유



## 1.8 플러터가 앞으로 제공할 혜택 : 웹&데스크톱 앱



## 1.9 플러터 동작 원리 간단 소개

> 넓은 의미로 플러터는 웹의 리액트처럼 **리액티브**, **선언형**, 조합할 수 있는 **뷰 계층 라이브러리**다
> (플러터는 **렌더링 엔진도 포함**하므로 **리액트와 브라우저를 합한 것** 과 비슷하다)
>
> 즉 위젯이라는 작은 컴포넌트를 조합해 모바일 UI를 만든다
> 플러터의 모든 것은 위젯이며, 위젯은 뷰를 묘사하는 다트 클래스이다



### 1.9.1 모든 것이 위젯

- 레이아웃 : Row, Column, Scaffold, Stack
- 구조 : Button, Toast, MenuDrawer
- 스타일 : TextStyle, Color
- 애니메이션 : FadeInPhoto, Transform
- 위치와 정렬 : Center, Padding



### 1.9.2 위젯으로 UI 만들기

> 플러터는 상속(inheritance)보다 조합(composition)을 우선시하며, 이를 이용해 고유한 위젯을 만든다
>
> 위젯은 다양한 생명주기(life cycle) 메서드와 객체 멤버를 포함한다
> 가장 중요한 메서드 중 하나는 build()이다. 모든 플러터 위젯은 build() 메서드를 반드시 정의해야 한다
> build()메서드는 반환하는 위젯을 통해 뷰를 실질적으로 묘사한다

```dart
Class CustomWidget extends Button{}
///상속으로 커스텀 위젯을 만들지 않기 때문에, 위의 코드는 올바른 코드가 아니다
```

```dart
Class CustomWidget extends StatelessWidget{
    @override
    build(){
        return Center(
            child: Button(
                child: Text('조합으로 만드는 올바른 커스텀 위젯의 예시'),
            ),
        );
    }
}
```



### 1.9.3 위젯 형식

> p46 그림 1-9 참고

- 상태가 없는 위젯 (StatelessWidget)
  - 어떠한 정보를 저장하지 않으므로 위젯이 사라져도 별 일이 없다 (상태 정보가 없음)
  - 언제 리빌드해야 하는지  프레임워크에 알리지 않는다
  - 프레임워크가 위젯을 언제 리빌드해야 하는지 알려준다
  - 생명주기가 없다 (?)
- 상태가 있는 위젯 (StatefulWidget)
  - 항상 State 객체를 갖는다 (상태 정보가 필수)
  - setState라는 특별한 메서드로, 언제 리빌드해야 하는지를 프레임워크에 알린다
  - 생명주기
    1. 객체가 만들어 질 때, 위젯과 관련된 State 객체를 만든다
    2. 위젯이 마운트되면 플러터가 initState를 호출한다
    3. 상태를 초기화하면 플러터가 위젯을 빌드한다 (화면에 위젯이 그려짐)
    4. 다음 세 가지 이벤트 중 하나를 기다린다
       1. 사용자가 앱의 다른 화면으로 이동하면서 **폐기(dispose)**됨
       2. 트리의 다른 위젯이 갱신되면서 위젯이 의존하는 설정이 바뀜, 위젯의 상태는 didUpdateWidget을 호출하며 필요하면 **리빌드(rebuild)**함
       3. (버튼 등을 통한) 사용자의 **setState 호출**로, 위젯의 내부 상태가 갱신되어 위젯을 플러터가 **리빌드(rebuild)**함



## 1.10 플러터 렌더링: 내부 동작 원리

> **제약(constraint)정보**를 **부모위젯에서 자식위젯**으로 **트리를 타고 내려가며** 전파
> **정보**(각 위젯의 크기와 위치 등)를 **자식위젯에서 부모위젯**으로 **트리를 타고 올라가며** 전파



- **플러터 위젯은 리액티브**이다
  - 외부(또는 setState)에서 새 정보를 얻으면 이에 반응하고, 필요하면 플러터가 리빌드를 진행한다
- 버튼을 통한 setState 호출 예시
  1. 사용자가 버튼을 누름
  2. Button.onPressed 콜백에서 setState를 호출
  3. Button의 상태가 dirty로 바뀌었으면, 플러터는 이 위젯을 리빌드함
  4. 트리에서 기존 위젯을 새 위젯으로 바꿈
  5. 플러터가 새 트리를 그림



### 1.10.1 위젯 트리와 레이아웃 조립

- 렌더링의 단계
  1. 애니메이트 - 애니메이션 티커 타이머 시작
  2. 빌드 - 플러터가 위젯 트리를 빌드함
  3. 레이아웃 - 플러터가 트리를 내려갔다가 거슬러 올라오면서 대상 위젯의 레이아웃을 결정함
  4. 조립 - 각 픽셀 준비
  5. 그리기 - 플러터가 위젯을 그림



### 1.10.2 조립 과정

> 조립 과정은 그리기 과정과 별도이고,
> 조립 과정과 그리기 과정을 분리함으로 성능을 높일 수 있다
> (조립된 위젯 재사용 가능)

1. 각 위젯의 레이아웃을 결정하고 다른 위젯과 충돌하지 않음을 확인
2. 플러터가 위젯을 그릴 준비를 함 (조립 과정)
3. 플러터가 위젯에 실제 화면상의 좌표를 제공하고, 위젯은 자신이 차지할 실제 픽셀의 수를 알게 됨



### 1.10.3 화면에 그리기

> 래스터라이징(rasterizing) - 텍스트와 이미지를 프린트 가능한 형태로 전환

4. 엔진이 전체 트리를 그릴 수 있는 뷰로 모은다

5. 운영체제를 통해 화면에 그리도록 요청 (래스터라이징)



## 정리

- 플러터는 모바일 SDK이며 다트로 구현된다
- 다트는 구글이 만든 언어로 자바스크립트로 컴파일 할 수 있다
- 다트는 빠르며, 엄격한 형식을 지원하고 배우기 쉽다
- 플러터는 네이티브 디바이스 코드로 컴파일되므로 다른 크로스 플랫폼 기술보다 성능이 뛰어남
- 다트의 JIT, 플러터의 핫 리로드 덕분에 최상의 개발자 경험을 제공한다
- 이미 두 개의 네이티브 팀을 보유한 회사에게는 좋은 선택지가 아닐 수 있다
- 플러터의 모든 것은 위젯이다
- 위젯은 뷰를 묘사하는 단순한 다트 클래스이고, 여러 작은 위젯을 조립해 위젯 트리를 완성하며 UI를 만든다
- 위젯은 크게 상태가 없는 위젯과 상태가 있는 위젯으로 분류된다
- 플러터는 위젯 생명주기 메서드, 특별한 State 객체 등 상태 관리 도구를 제공한다





# 2장 다트



## 2.2 다트의 프로그래밍 개념

- 다트는 객체지향 언어이며 단일 상속(single inheritance)을 지원한다
- 다트에서 모든 것이 객체이며 모든 객체는 클래스의 인스턴스이다
- 모든 객체는 Object 클래스를 상속받는다 (심지어 숫자도 기본형이 아니라 객체)
- 다트는 형식을 갖는다 (문자열을 반환한다고 선언한 함수에서 숫자를 반환할 수 없다)
  - 형식 시스템의 가장 큰 장점 : 버그를 줄일 수 있다
- 다트는 최상위 수준 함수와 변수를 지원하며 이를 라이브러리 멤버라 부른다
- 다트는 어휘적(exically)으로 한정된다



